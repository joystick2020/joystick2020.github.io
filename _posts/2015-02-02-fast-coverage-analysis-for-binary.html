---
layout: post
title: Fast coverage analysis for binary applications
date: '2015-02-02T06:39:00.000-08:00'
author: aristide_fattori
image: bisect-thumb.png
tags:
- branch trace store
- CFG
- bts
- tracing
- fuzzing
modified_time: '2015-02-02T06:39:24.108-08:00'
thumbnail: http://3.bp.blogspot.com/-s3CpHzh9-SM/VM0Oa9AcZ6I/AAAAAAAAFoA/n2KAPCrhPuA/s72-c/bisect-thumb.png
blogger_id: tag:blogger.com,1999:blog-7491184756351885467.post-6517910978918174367
blogger_orig_url: http://joystick.artificialstudios.org/2015/02/fast-coverage-analysis-for-binary.html
---

<div style="text-align: justify;"><div style="text-align: right;"><span style="color: #999999;">(This post is a joint work with <a href="https://twitter.com/rpaleari" target="_blank">@rpaleari</a>, see also his blog <a href="http://randomthoughts.greyhats.it/" target="_blank">here</a>) </span></div><br />Despite its simplicity, <a href="http://en.wikipedia.org/wiki/Fuzz_testing" target="_blank">fuzzing</a> has become a more and more popular technique for finding software bugs (and possibly security vulnerabilities), especially when dealing with complex or closed-source applications. The recipe for a basic fuzzer is well-known: pick your favorite target application and run it on “weird” inputs. Hopefully, one of these inputs will trigger some corner-case behaviors, which produce externally-observable side effects, such as a program crash. <br /><br />The main drawback of this approach is that, at least in its naive form, it can trigger only very shallow program paths: it may take a humongous number of inputs to reach even slightly convoluted branches. For example, consider a statement such that "<span style="font-family: &quot;Courier New&quot;,Courier,monospace;">if (a == 31337) then { … }</span>"; to reach the "<span style="font-family: &quot;Courier New&quot;,Courier,monospace;">then</span>" block using a completely blind approach, the fuzzer would need to guess the correct value for variable "<span style="font-family: &quot;Courier New&quot;,Courier,monospace;">a</span>" out of 2**32 distinct possibilities (considering 32-bit integers). To address this limitation, "smarter" testing approaches have been proposed. Among these, symbolic and concolic <a href="http://research.microsoft.com/en-us/um/people/pg/public_psfiles/ndss2008.pdf" target="_blank">execution techniques</a> have recently become quite popular among security researchers, but their applications to real-world products are still questionable, especially because of the complexity explosion when dealing with the intricacies of real-world software. Thus, simple fuzzing is still widely used, and many researchers strive to find ways to make it more effective while, at the same time, trying to keep its overhead as close as possible to that of a native black-box approach. <br /><br />Following this trend, recently, <a href="https://twitter.com/lcamtuf" target="_blank">@lcamtuf</a> has demonstrated that simple fuzz testing can still identify dangerous bugs: his "<a href="http://lcamtuf.coredump.cx/afl/" target="_blank">american fuzzy lop</a>" (afl) approach consists in running the target program over a carefully selected set of test cases, while observing it via compile-time instrumentation that permits to monitor instruction-level coverage. In a nutshell, test cases that reach novel instructions are "more interesting", as they could also trigger different program behaviors. <br /><br />We were recently talking about the applicability of the afl approach to binary applications as well. The first problem concerns the monitoring phase: how to calculate the coverage for a given input? Obviously, as the target application is binary-only, source-level instrumentation is not an option. <br /><br /><h3>Coverage analysis of binary applications</h3>Strictly speaking, for the sake of tracking the progress of our fuzzing process, instead of instruction coverage, an analysis at the basic-block level should suffice: as basic blocks are uninterruptible single-entry, single-exit sequences of instructions, the two should be roughly equivalent (at least if we ignore asynchronous events). <br /><br />As an example, the following x86 assembly snippet encodes a simple loop.<br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: 0em; overflow: auto; padding: .2em .6em; width: auto;"><pre style="line-height: 125%; margin: 0;"><span style="color: #997700; font-weight: bold;">B1:</span><br />    xor <span style="color: #333333;">%</span>ecx, <span style="color: #333333;">%</span>ecx<br /><br /><span style="color: #997700; font-weight: bold;">B2:</span><br />    inc <span style="color: #333333;">%</span>ecx<br />    cmp <span style="color: #005588;">$</span><span style="color: #005588; font-weight: bold;">0x3</span>, <span style="color: #333333;">%</span>ecx<br />    jb B2<br /><br /><span style="color: #997700; font-weight: bold;">B3:</span><br />    ...<br /></pre></div><br />When monitoring the execution of this code, we would like to produce the basic blocks trace <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&lt;B1, B2, B2, B2, B3&gt;</span>. <br /><br /><h3>Monitoring via binary instrumentation</h3>The problem of monitoring binary applications for coverage analysis was recently discussed also by some researchers (e.g., see <a href="https://twitter.com/matalaz" target="_blank">@matalaz</a> presentation <a href="http://www.slideshare.net/JoxeanKoret/the-nightmare-fuzzing-suite-and-blind-code-coverage-fuzzer" target="_blank">here</a>) who suggested to rely on binary instrumentation, e.g., using <a href="https://software.intel.com/en-us/articles/pin-a-dynamic-binary-instrumentation-tool" target="_blank">Pin</a>, <a href="http://www.dynamorio.org/" target="_blank">DynamoRIO</a>, or <a href="http://valgrind.org/" target="_blank">Valgrind</a>. More recently, other researchers started to implement similar approaches in order to port "afl" to closed-source applications, both relying on <a href="https://github.com/mothran/aflpin" target="_blank">PIN</a> or <a href="https://code.google.com/p/qemu-afl-support/" target="_blank">QEMU</a> (the latter has also been integrated into "afl" since version 1.31b). <br /><br />But what about performances? One of the main strengths of random fuzzing approaches is their high execution rate, as fuzzed inputs are executed nearly at native speed. But if the monitoring phase costs too much, the whole process is slowed down significantly. <br /><br />As an example, consider this minimal Pin tool that inserts a callback function before the execution of every program basic block (well, actually at every Pin "trace", i.e., a single-entry sequence of basic blocks, but we can ignore the differences here). Obviously this trivial tool cannot be considered as a real process monitor, but can certainly be used to estimate a lower bound for the performances of this approach.<br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: 0em; overflow: auto; padding: .2em .6em; width: auto;"><pre style="line-height: 125%; margin: 0;"><span style="color: #557799;">#include "pin.H"</span><br /><br />VOID <span style="color: #0066bb; font-weight: bold;">CallbackTrace</span>(TRACE trace, VOID <span style="color: #333333;">*</span>v) {<br />   <span style="color: #888888;">// Insert callback instructions here</span><br />}<br /><br /><span style="color: #333399; font-weight: bold;">int</span> <span style="color: #0066bb; font-weight: bold;">main</span>(<span style="color: #333399; font-weight: bold;">int</span> argc, <span style="color: #333399; font-weight: bold;">char</span> <span style="color: #333333;">**</span>argv) {<br />  PIN_Init(argc, argv);<br />  TRACE_AddInstrumentFunction(CallbackTrace, <span style="color: #0000dd; font-weight: bold;">0</span>);<br />  PIN_StartProgram();<br />  <span style="color: #008800; font-weight: bold;">return</span> <span style="color: #0000dd; font-weight: bold;">0</span>;<br />}<br /></pre></div><br />Even such a trivial Pin tool introduces a significant overhead. As an example, running it over <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">/bin/ls</span> takes about 340ms on a normal laptop, a 100x overhead with respect to a native execution. Pin experts can certainly further reduce the performance penalty with some tweaks, but the order of magnitude should not change very much: after all, dynamic binary translation tools have to decode, translate, instrument, and finally recompile target code before executing it.<br /><br /><h3>Introducing Intel BTS</h3>Modern processors include sophisticated debug and performance monitoring facilities. Intel introduced these features in early Pentium processors and continued to extend them in subsequent CPU models (see chapters 17 and 18 of <a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html" target="_blank">Intel manuals</a> for details). <br /><br />Among these facilities, Intel BTS ("Branch Trace Store") permits to record a trace of executed branch instructions to a memory buffer. In a nutshell, BTS records executed control-flow edges, as (source, destination) pairs. This mechanism is quite customizable, and can be configured to generate an interrupt when the BTS buffer is almost full, monitor only a specified privilege level (e.g., to track only user-space branches), or limit the capture to selected branch types (e.g., indirect/conditional branches, returns, calls). These characteristics make BTS an attractive approach for performing branch-level coverage analysis of a binary application. <br /><br />BTS is configured by writing settings to dedicated MSR registers (again, see Intel manuals for low-level details). These operations should be carried out by kernel-level code, thus specific OS modules are required to permit the implementation of user-space monitor applications. Fortunately, Intel BTS is already supported by latest versions of the Linux performance monitoring subsystem, and is exposed to user-space via the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><a href="http://man7.org/linux/man-pages/man2/perf_event_open.2.html" target="_blank">perf_event_open()</a></span> system call (for a user-space client see also the <a href="https://perf.wiki.kernel.org/index.php/Main_Page" target="_blank"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">perf</span> tool</a>).<br /><br /><h3>Coverage analysis using Intel BTS</h3>Despite Linux performance monitoring is documented quite well, details about how to use <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">perf_event_open()</span> specifically for controlling BTS are scarce, except for <a href="https://svn.physiomeproject.org/svn/opencmissextras/cm/trunk/external/packages/PAPI/papi-4.2.0/src/libpfm4/perf_examples/x86/bts_smpl.c" target="_blank">few public examples</a>: it is quite easy to invoke the API with improper parameters that force the subsystem to "fall-back" on software-based performance monitoring, with significant performance penalties.  Thus, during our experiments we developed a coverage analysis tool that leverages this API to perform hardware-assisted tracing of the basic blocks executed by a target application. Information about executed basic blocks is dumped to a <a href="https://developers.google.com/protocol-buffers/" target="_blank">Google protobuf</a> file, for easy post-processing.  As an example, the following excerpt show the tracing of <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">/bin/ls</span> and the dump in human-readable form of the resulting protobuf file: <br /><pre>$ ./bts_trace -f /dev/shm/ls.trace -- /bin/ls &gt;/dev/null<br />[*] Got 50758 events (2486 CFG edges), serializing to /dev/shm/ls.trace<br /><br />$ python trace.py /dev/shm/ls.trace<br />#### Trace '/dev/shm/ls.trace' ####<br />[/dev/shm/ls.trace] cmd: test, data: 0 bytes, time: 2015-01-29 19:21:58<br />hash: 2dc92a, edges(s): 2486, exception(s): 0<br /><br /> - CFG edges<br /> [00402176 -&gt; 0040217d] 1 hit<br /> [00402181 -&gt; 00412513] 1 hit<br /> [00402196 -&gt; 7f1d372dc2f0] 28 hit<br /> [004021c0 -&gt; 004021c6] 1 hit<br /> [004021c0 -&gt; 7f1d36b281b0] 7 hit<br /> [004021cb -&gt; 00402190] 1 hit<br /> ...<br /> [7f1d372e0ac7 -&gt; 7f1d372e0a30] 2 hit<br /> [7f1d372e0af7 -&gt; 7f1d372e0a20] 2 hit<br /> [7f1d372e0b1b -&gt; 7f1d372e0635] 4 hit<br /><br /> - Memory regions<br /> [0x00400000, 0x0041bfff] /bin/ls<br /> [0x7f1d3625d000, 0x7f1d36479fff] /lib/x86_64-linux-gnu/libpthread-2.19.so<br /> [0x7f1d3647a000, 0x7f1d3667efff] /lib/x86_64-linux-gnu/libattr.so.1.1.0<br /> ...<br /></pre><br />Running our tool over <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">/bin/ls</span> takes about 90ms, about 1/4 of the time required by the Pin-based tracer we sketched above. Consider also that this includes the time spent for the creation &amp; serialization of the protobuf stream to file, while none of these operations are performed by the Pin-based tracer: the latter introduces a very high overhead with just the instrumentation required to trace BBs, without auxiliary functions for storing and eventually serializing the execution trace. <br /><br />Both the BTS tracer and the trace viewer are available <span style="color: red;"><a href="https://github.com/rpaleari/fuzztrace">here</a></span>, so feel free to give them a try! The current implementation is quite rough, so we believe there is still room for improvement. <br /><br /><h3>Construction of the basic block "hit map"</h3>Starting from the generated trace file, it is also possible to build the control-flow graph (CFG). Clearly, using this approach we can build a dynamic CFG only, i.e., a graph that includes control-flow edges observed in the concrete execution, but multiple execution traces could be also merged together to better approximate the static CFG. In addition, the information about how many times each basic block has been executed (i.e., the number of "hits") could also be used to generate a "hit map" of basic blocks frequencies, possibly to guide the fuzz testing phase. <br /><br />As an example, consider the following C implementation of a classical binary search algorithm. <br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: 0em; overflow: auto; padding: .2em .6em; width: auto;"><pre style="line-height: 125%; margin: 0;"><span style="color: #008800; font-weight: bold;">static</span> <span style="color: #333399; font-weight: bold;">int</span> <span style="color: #0066bb; font-weight: bold;">bisect</span>(<span style="color: #333399; font-weight: bold;">int</span> v[], <span style="color: #333399; font-weight: bold;">int</span> size, <span style="color: #333399; font-weight: bold;">int</span> key) {<br />  <span style="color: #333399; font-weight: bold;">int</span> start, end, middle, pos;<br /><br />  start <span style="color: #333333;">=</span> <span style="color: #0000dd; font-weight: bold;">0</span>;<br />  end <span style="color: #333333;">=</span> size<span style="color: #333333;">-</span><span style="color: #0000dd; font-weight: bold;">1</span>;<br />  pos <span style="color: #333333;">=</span> <span style="color: #333333;">-</span><span style="color: #0000dd; font-weight: bold;">1</span>;<br />  <span style="color: #008800; font-weight: bold;">while</span> (start <span style="color: #333333;">&lt;=</span> end) {<br />    middle <span style="color: #333333;">=</span> (end<span style="color: #333333;">+</span>start)<span style="color: #333333;">/</span><span style="color: #0000dd; font-weight: bold;">2</span>;<br />    <span style="color: #008800; font-weight: bold;">if</span> (v[middle] <span style="color: #333333;">&gt;</span> key) {<br /> end <span style="color: #333333;">=</span> middle<span style="color: #333333;">-</span><span style="color: #0000dd; font-weight: bold;">1</span>;<br />    } <span style="color: #008800; font-weight: bold;">else</span> <span style="color: #008800; font-weight: bold;">if</span> (v[middle] <span style="color: #333333;">&lt;</span> key) {<br /> start <span style="color: #333333;">=</span> middle<span style="color: #333333;">+</span><span style="color: #0000dd; font-weight: bold;">1</span>;<br />    } <span style="color: #008800; font-weight: bold;">else</span> {<br /> pos <span style="color: #333333;">=</span> middle;<br /> <span style="color: #008800; font-weight: bold;">break</span>;<br />    }<br />  }<br /><br />  <span style="color: #008800; font-weight: bold;">return</span> pos;<br />}<br /></pre></div><br />The CFG in Figure 1 is a "hit map" for a monitored execution of <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">bisect()</span>, on a sorted array of 1024 elements. Despite we previously shown the C source for this method, the CFG has been constructed dynamically from the binary code. Colors reflect the number of node hits, i.e., how many times the node has been executed in the observed execution. Nodes and edges labels indicate the actual hits. It is finally worth noting that for conditional branches, whenever possible, we also add to the graph those edges that have not been taken during the observed execution; this is done just to better approximate the static CFG of the application, but is technically not required to support a subsequent fuzzing phase.<br /><br />To conclude, Figure 2 shows another example of a "hit map", this time for an execution of a recursive quicksort algorithm, running on a random array of 1024 integers (C code for this test case is available <span style="color: red;"><a href="https://github.com/rpaleari/fuzztrace/tree/master/tests">here</a></span>).<br /><br /><table><tbody><tr><td><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/-KB8eowoMAbE/VM0JLGARVqI/AAAAAAAAFnY/tyLs6QroTcE/s1600/bisect.png" imageanchor="1" style="margin-left: auto; margin-right: auto;" target="_blank"><img border="0" src="http://3.bp.blogspot.com/-s3CpHzh9-SM/VM0Oa9AcZ6I/AAAAAAAAFoA/n2KAPCrhPuA/s1600/bisect-thumb.png" height="320" width="203" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Figure 1 - "Hit map" for the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">bisect()</span> function (click on the image to enlarge)</td></tr></tbody></table></td><td><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-ECLY3LwER9Q/VM0JcyloFcI/AAAAAAAAFnk/_8KqBLuwJNI/s1600/quicksort.png" imageanchor="1" style="margin-left: auto; margin-right: auto;" target="_blank"><img border="0" src="http://4.bp.blogspot.com/-dsMfcqYGfIQ/VM0Osd3SWbI/AAAAAAAAFoI/Hjj4IACP7V0/s1600/quicksort-thumb.png" height="320" width="205" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Figure 2 - "Hit map" for an implementation of Quicksort (click on the image to enlarge)</td></tr></tbody></table></td></tr></tbody></table><br /><h3>Conclusions</h3>Hardware-assisted performance monitoring could be an interesting approach to implement efficient coverage analysis tools, which in turn can be employed to support fuzz testing and other security-related applications. At this aim, we developed a <span style="color: red;"><a href="https://github.com/rpaleari/fuzztrace/">sample tool</a></span> that leverages the Intel "Branch Trace Store" facility. Our current implementation is just a little more than a proof-of-concept. Currently, its major limitation is that, in some situations, we lose some branch events. This may happen when the branch rate is very high, such as when the monitored application enters a tight loop. We are still investigating these issues, and we hope some interested reader could also contribute with some patches ;-) </div><br />
