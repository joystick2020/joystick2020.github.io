---
layout: post
title: Mac OS X local privilege escalation (IOBluetoothFamily)
date: '2014-10-30T03:54:00.000-07:00'
author: aristide_fattori
tags: 
modified_time: '2014-10-31T02:10:04.759-07:00'
thumbnail: http://3.bp.blogspot.com/-25lKD5inhyo/VFEw-jp-kkI/AAAAAAAAFj8/YIaG2S2P35o/s72-c/apple.png
blogger_id: tag:blogger.com,1999:blog-7491184756351885467.post-1685801176820414846
blogger_orig_url: http://joystick.artificialstudios.org/2014/10/mac-os-x-local-privilege-escalation.html
---

<div style="text-align: right;"><span style="color: #999999;">(This post is a joint work with <a href="https://twitter.com/rpaleari">@rpaleari</a>, see also his blog <a href="http://randomthoughts.greyhats.it/">here</a>) </span></div><div style="text-align: justify;"><br /><a href="http://3.bp.blogspot.com/-25lKD5inhyo/VFEw-jp-kkI/AAAAAAAAFj8/YIaG2S2P35o/s1600/apple.png" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" src="http://3.bp.blogspot.com/-25lKD5inhyo/VFEw-jp-kkI/AAAAAAAAFj8/YIaG2S2P35o/s1600/apple.png" height="149" width="200" /></a>Nowadays, exploitation of user-level vulnerabilities is becoming more and more difficult, because of the widespread diffusion of several protection methods, including ASLR, NX, various heap protections, stack canaries, and sandboxed execution. As a natural consequence, instead of extricating themselves with such a plethora of defensive methods, attackers prefer to take the “easy” way and started to move at the kernel-level, where sophisticated protection techniques are still not very common (indeed, things like as KASLR and SMEP are implemented only in the latest versions of the most popular OSes). This trend is also confirmed by the rising number of kernel-level vulnerabilities reported in the last few months in Windows, <a href="http://www.cvedetails.com/vulnerability-list/vendor_id-33/product_id-47/cvssscoremin-7/cvssscoremax-7.99/Linux-Linux-Kernel.html" target="_blank">Linux</a>, and <a href="http://googleprojectzero.blogspot.it/" target="_blank">OS X</a>.</div><br /><div style="text-align: justify;">Following this trend, we recently looked at few OS X drivers (“KEXT”s) and found a integer signedness bug affecting service <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">IOBluetoothHCIController</span> (implemented by the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">IOBluetoothFamily</span> KEXT). This vulnerability can be exploited by a local attacker to gain root privileges. The issue is present on the latest versions of OS X Mavericks (tested on 10.9.4 and 10.9.5), but has been “silently” patched by Apple in OS X Yosemite.</div><br /><h3>Vulnerability overview</h3><div style="text-align: justify;">In a nutshell, the bug lies in the<span style="font-family: &quot;Courier New&quot;,Courier,monospace;"> IOBluetoothHCIUserClient::SimpleDispatchWL()</span> function. The function eventually takes a user-supplied 32-bit signed integer value and uses it to index a global array of structures containing a function pointer. The chosen function pointer is finally called. As the reader can easily imagine, <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SimpleDispatchWL()</span> fails at properly sanitizing the user-supplied index, thus bad things may happen if a malicious user is able to control the chosen function pointer.<br /><br />More in detail, the vulnerable part of the function is summarized in the pseudocode below. At line 14, the user-supplied 32-bit integer is casted to a 64-bit value. Then, the "if" statement at line 16 returns an error if the casted (signed) value is greater than the number of methods available in the global <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">_sRoutines</span> array; obviously, due to the signed comparison, any negative value for the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">method_index</span> variable will pass this test. At line 20 <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">method_index</span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"></span> is used to access the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">_sRoutines</span> array, and the retrieved callback is finally called at line 23.</div><br /><!-- HTML generated using hilite.me --> <br /><div style="background: #ffffff; overflow: auto; padding: .2em .6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0; padding-right: 1em;"> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26</pre></td><td><pre style="line-height: 125%; margin: 0;"><span style="color: #008800; font-weight: bold;">typedef</span> <span style="color: #008800; font-weight: bold;">struct</span> {<br />  <span style="color: #333399; font-weight: bold;">void</span> (<span style="color: #333333;">*</span>function_pointer)();<br />  uint64 num_arguments;<br />} BluetoothMethod;<br /><br />BluetoothMethod _sRoutines[] <span style="color: #333333;">=</span> {<br />  ...<br />};<br /><br />uint64 _sRoutineCount <span style="color: #333333;">=</span> <span style="color: #008800; font-weight: bold;">sizeof</span>(_sRoutines)<span style="color: #333333;">/</span><span style="color: #008800; font-weight: bold;">sizeof</span>(BluetoothMethod);<br /><br />IOReturn IOBluetoothHCIUserClient<span style="color: #333333;">::</span>SimpleDispatchWL(IOBluetoothHCIDispatchParams <span style="color: #333333;">*</span>params) {<br />  <span style="color: #888888;">// Here "user_param" is a signed 32-bit integer parameter</span><br />  int64 method_index <span style="color: #333333;">=</span> (int64) user_param;<br /><br />  <span style="color: #008800; font-weight: bold;">if</span> (method_index <span style="color: #333333;">&gt;=</span> _sRoutineCount) {<br />    <span style="color: #008800; font-weight: bold;">return</span> kIOReturnUnsupported;<br />  }<br /><br />  BluetoothMethod method <span style="color: #333333;">=</span> _sRoutines[method_index];<br />  ...<br />  <span style="color: #008800; font-weight: bold;">if</span> (method.num_arguments <span style="color: #333333;">&lt;</span> <span style="color: #0000dd; font-weight: bold;">8</span>) {<br />       method.function_pointer(...);<br />  }<br />  ...  <br />}<br /></pre></td></tr></tbody></table></div><br /><h3>Exploitation details</h3><div style="text-align: justify;">Exploitation of this vulnerability is just a matter of supplying the proper negative integer value in order to make <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">IOBluetoothFamily</span> index the global <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">_sRoutines</span> structure out of its bounds, and to fetch an attacker-controlled structure. The supplied value must be negative to index outside the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">_sRoutines</span> structure while still satisfying the check at line 16.<br /><br />As a foreword, consider that for our "proof-of-concept" we disabled both SMEP/SMAP and KASLR, so some additional voodoo tricks are required to get a fully weaponized exploit. Thus, our approach was actually very simple: we computed a value for the user-supplied parameter that allowed us to index a <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">BluetoothMethod</span> structure such that <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">BluetoothMethod.function_ptr</span> is a valid user-space address (where we placed our shellcode), while <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">BluetoothMethod.num_arguments</span> is an integer value less than 8 (to satisfy the check performed by <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SimpleDispatchWL()</span> at line 22).<br /><br />As shown in the C code fragment above, the user-supplied 32-bit value (<span style="font-family: &quot;Courier New&quot;,Courier,monospace;">user_param</span>) is first casted to a 64-bit signed value, and then used as an index in <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">_sRoutines</span>. Each entry of the global <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">_sRoutines</span> array is 16-byte wide (two 8-byte values). These operations are implemented by the following assembly code:</div><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; overflow: auto; padding: .2em .6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0; padding-right: 1em;"> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15</pre></td><td><pre style="line-height: 125%; margin: 0;"><span style="color: #888888;">; r12+70h points to the user-supplied index value</span><br /><span style="color: #0066bb; font-weight: bold;">mov</span>     <span style="color: #007020;">ecx</span>, [<span style="color: #996633;">r12</span><span style="color: #333333;">+</span><span style="color: #005588; font-weight: bold;">70h</span>]<br /><span style="color: #0066bb; font-weight: bold;">mov</span>     <span style="color: #007020;">r13d</span>, <span style="color: #996633;">kIOReturnUnsupported</span><br /><span style="color: #0066bb; font-weight: bold;">lea</span>     <span style="color: #007020;">rdx</span>, <span style="color: #996633;">_sRoutineCount</span><br /><span style="color: #0066bb; font-weight: bold;">cmp</span>     <span style="color: #007020;">ecx</span>, [<span style="color: #007020;">rdx</span>]<br /><span style="color: #0066bb; font-weight: bold;">jge</span>     <span style="color: #996633;">fail</span><br /><span style="color: #888888;">; Go on and fetch _sRoutine[method_index</span><span style="color: #888888;">]</span><br /><span style="color: #0066bb; font-weight: bold;">...</span><br /><span style="color: #0066bb; font-weight: bold;">movsxd</span>  <span style="color: #007020;">rax</span>, <span style="color: #007020;">ecx</span>             <span style="color: #888888;">; Sign extension to 64-bit value</span><br /><span style="color: #0066bb; font-weight: bold;">shl</span>     <span style="color: #007020;">rax</span>, <span style="color: #0000dd; font-weight: bold;">4</span>               <span style="color: #888888;">; </span><span style="color: #888888;"><span style="color: #888888;">method_index</span> *= sizeof(BluetoothMethod)</span><br /><span style="color: #0066bb; font-weight: bold;">lea</span>     <span style="color: #007020;">rdx</span>, <span style="color: #996633;">_sRoutines</span><br /><span style="color: #0066bb; font-weight: bold;">mov</span>     <span style="color: #007020;">esi</span>, [<span style="color: #007020;">rdx</span><span style="color: #333333;">+</span><span style="color: #007020;">rax</span><span style="color: #333333;">+</span><span style="color: #0000dd; font-weight: bold;">8</span>]     <span style="color: #888888;">; esi = _sRoutines[</span><span style="color: #888888;"><span style="color: #888888;">method_index</span>].num_arguments</span><br /><span style="color: #0066bb; font-weight: bold;">cmp</span>     <span style="color: #007020;">esi</span>, <span style="color: #0000dd; font-weight: bold;">7</span>               <span style="color: #888888;">; Check method.num_arguments &lt; 8</span><br /><span style="color: #0066bb; font-weight: bold;">ja</span>      <span style="color: #996633;">loc_289BA</span><br /><span style="color: #0066bb; font-weight: bold;">...</span><br /></pre></td></tr></tbody></table></div><br /><div style="text-align: justify;">At a higher-level, the address of the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">BluetoothMethod</span> structure fetched when processing an index value "<span style="font-family: &quot;Courier New&quot;,Courier,monospace;">user_param</span>" is computed by the following formula:</div><div style="text-align: center;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">struct_addr = (ext(user_param &amp; 0xffffffff) * 16) + _sRoutine</span></div><div style="text-align: justify;">Where <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">ext()</span> is the sign-extension operation (implemented by the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">movsxd</span> instruction in the assembly code snipped above).<br /><br />By solving this formula for <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">user_param</span> and searching inside the kernel address space, we found several candidate addresses that matched our criteria (i.e., a valid user-space pointer followed by an integer value &lt; 8). The rest of the exploit is just a matter of <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">mmap()</span>'ing the shellcode at the proper user-space address, connecting to the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">IOBluetoothHCIController</span> service and invoking the vulnerable method.<br /><br />The source code for a (very rough) proof-of-concept implementation of the aforementioned exploit is available <a href="http://goo.gl/WvJNHn" target="_blank">here</a>, while the following figure shows the exploit "in action".<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-5eiPyvF0S4A/VFFeUZ-JXOI/AAAAAAAAFkc/0Oug4OD9CJQ/s1600/shell.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://2.bp.blogspot.com/-5eiPyvF0S4A/VFFeUZ-JXOI/AAAAAAAAFkc/0Oug4OD9CJQ/s1600/shell.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Execution of our "proof-of-concept" exploit</td></tr></tbody></table><br /><h3>Patching</h3>We verified the security issue both on OS X Mavericks 10.9.4 and 10.9.5 (MD5 hash values for the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">IOBluetoothFamily</span> KEXT bundle on these two OS versions are <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">2a55b7dac51e3b546455113505b25e75</span> and <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">b7411f9d80bfeab47f3eaff3c36e128f</span>, respectively). After the release of OS X Yosemite (10.10), we noticed the vulnerability has been silently patched by Apple, with no mention about it in the <a href="http://support.apple.com/kb/HT6535" target="_blank">security change log</a>.<br /><br />A side-by-side comparison between versions 10.9.x and 10.10 of <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">IOBluetoothFamily</span> confirms Apple has patched the device driver by rejecting negative values for the user-supplied index. In the figure below, the user-supplied index value is compared against <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">_sRoutineCount</span> (orange basic block). Yosemite adds an additional check to ensure the (signed) index value is non-negative (green basic block, on the right).<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-pIlZS05n5KU/VFE3hytbeMI/AAAAAAAAFkM/912kMRyaHNw/s1600/fix.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://2.bp.blogspot.com/-pIlZS05n5KU/VFE3hytbeMI/AAAAAAAAFkM/912kMRyaHNw/s1600/fix.png" height="289" width="640" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Comparison of the vulnerable OS X driver (Mavericks, on the left) and patched version (Yosemite, on the right)</td></tr></tbody></table></div><br /><h3>Conclusions</h3><div style="text-align: justify;">We contacted Apple on October 20th, 2014, asking for their intention to back-port the security fix to OS X Mavericks. Unfortunately, we got no reply, so we decided to publicly disclose the details of this vulnerability: Yosemite has now been released since a while and is available for free for Apple customers; thus, we don’t think the public disclosure of this bug could endanger end-users.<br /><br /><h3>Update (31/10/2014)</h3><span style="font-family: Arial; font-size: 15px; line-height: 1.15; white-space: pre-wrap;">Yesterday evening, few hours after the publication of our blog post, we received a reply from Apple Product Security. They confirmed the bug has been fixed in Yosemite, and they are still </span><span style="font-family: Arial; font-size: 15px; white-space: pre-wrap;">evaluating whether the issue should be addressed in the previous OS versions as well.</span></div>
